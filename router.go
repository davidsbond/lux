// Package lux contains types for creating an HTTP router for use in AWS lambda functions. The router supports
// RESTful HTTP methods & contains configuration for logging, request filtering & panic recovery.
package lux

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/aws/aws-lambda-go/events"
)

var (
	errNotAllowed    = errors.New("not allowed")
	errNotAcceptable = errors.New("not acceptable")
)

type (
	// The Router type handles incoming requests & routes them to the registered
	// handlers.
	Router struct {
		routes     []*Route
		middleware []MiddlewareFunc
		recovery   RecoverFunc
		log        *logrus.Logger
	}

	// The Route type defines a route that can be used by the router.
	Route struct {
		handler HandlerFunc
		method  string

		headers map[string]string
	}

	// The HandlerFunc type defines what a handler function should look like.
	HandlerFunc func(Request) Response

	// The MiddlewareFunc type defines what a middleware function should look like.
	MiddlewareFunc func(*Request) error

	// The RecoverFunc type defines what a panic recovery function should look like.
	RecoverFunc func(Request, error)

	// The Request type represents an incoming HTTP request.
	Request events.APIGatewayProxyRequest

	// The Response type represents an outgoing HTTP response.
	Response events.APIGatewayProxyResponse
)

// NewRouter creates a new lambda router.
func NewRouter() *Router {
	return &Router{
		routes:     []*Route{},
		middleware: []MiddlewareFunc{},
		log:        logrus.New(),
	}
}

// Handler adds a given handler to the router.
func (r *Router) Handler(method string, fn HandlerFunc) *Route {
	route := &Route{
		handler: fn,
		method:  method,
		headers: make(map[string]string),
	}

	r.routes = append(r.routes, route)

	r.log.WithFields(logrus.Fields{
		"method": method,
	}).Info("registered new handler")

	return route
}

// Middleware adds a middleware function to the router. These methods will be called
// prior to the route handler and allow you to modify the inbound request before
// processing it.
func (r *Router) Middleware(fn MiddlewareFunc) *Router {
	r.middleware = append(r.middleware, fn)

	return r
}

// Recovery sets a custom recovery handler that will be used when any
// handlers panic.
func (r *Router) Recovery(fn RecoverFunc) *Router {
	r.recovery = fn

	return r
}

// Logging sets the output for logs generated by the router.
func (r *Router) Logging(out io.Writer, format logrus.Formatter) *Router {
	r.log.Formatter = format
	r.log.Out = out

	return r
}

// HandleRequest determines which route an incoming HTTP request should be sent down. If no route has been
// specified for a given HTTP method, an error is returned.
func (r *Router) HandleRequest(req Request) (Response, error) {
	defer r.recover(req)
	ts := time.Now()

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
	}).Info("handling incoming request")

	// Look through each route
	for _, route := range r.routes {
		// If the route's method is correct but the request is not acceptable
		if err := route.canRoute(req); err == errNotAcceptable {
			return NewResponse(err.Error(), http.StatusNotAcceptable)
		} else if err == errNotAllowed {
			// If the method doesn't match, skip to the next route.
			continue
		}

		// Run any registered middleware
		for _, mid := range r.middleware {
			// If one returns an error, return a 500 response containing the error
			if err := mid(&req); err != nil {
				return NewResponse(err.Error(), http.StatusInternalServerError)
			}
		}

		resp := route.handler(req)

		r.log.WithFields(logrus.Fields{
			"status":    resp.StatusCode,
			"duration":  time.Since(ts).String(),
			"requestId": req.RequestContext.RequestID,
		}).Info("finished handling request")

		return resp, nil
	}

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
		"duration":  time.Since(ts).String(),
	}).Error("no handler specified to handle request")

	// Otherwise, create an error response
	return NewResponse(errNotAllowed.Error(), http.StatusMethodNotAllowed)
}

func (r *Router) recover(req Request) {
	var err error

	// If a panic was thrown
	if rec := recover(); rec != nil {
		// Attempt to parse it
		switch x := rec.(type) {
		case string:
			err = errors.New(x)
		case error:
			err = x
		default:
			err = fmt.Errorf("%s", x)
		}

		r.log.WithFields(logrus.Fields{
			"requestId": req.RequestContext.RequestID,
			"error":     err.Error(),
		}).Error("recovered from panic")

		// If a custom recover func was defined, use it.
		if r.recovery != nil {
			r.recovery(req, err)
		}
	}
}

// Headers allows you to specify headers a request should have in order to
// use this route.
func (r *Route) Headers(pairs ...string) *Route {
	// Loop through the headers
	for i := 0; i < len(pairs); i += 2 {
		// If we have an odd number of pairs, skip the last one.
		if len(pairs) < i+1 {
			break
		}

		key := pairs[i]
		value := pairs[i+1]

		// Register the required header
		r.headers[key] = value
	}

	return r
}

// CanRoute determines if the incoming request should use this route.
func (r *Route) canRoute(req Request) error {
	// If the request method does not match this route's method, we don't
	// support this request.
	if req.HTTPMethod != r.method {
		return errNotAllowed
	}

	// Loop through the expected headers & values
	for expKey, expValue := range r.headers {
		// If the header key is no present, we don't support this request
		if _, ok := req.Headers[expKey]; !ok {
			// NOT ACCEPTABLE
			return errNotAcceptable
		}

		// If the value is not what we expect from this key, we don't support
		// this request.
		if value := req.Headers[expKey]; value != expValue {
			return errNotAcceptable
		}
	}

	return nil
}

// NewResponse creates a new response object with a JSON encoded body and given
// status code.
func NewResponse(data interface{}, status int) (Response, error) {
	json, err := json.Marshal(data)

	if err != nil {
		return Response{}, fmt.Errorf("failed to encode response body, %v", err)
	}

	resp := Response{
		StatusCode: status,
		Body:       string(json),
		Headers:    make(map[string]string),
	}

	resp.Headers["Content-Type"] = "application/json"

	return resp, nil
}
