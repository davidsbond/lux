package lux

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/aws/aws-lambda-go/events"
)

const (
	errNoRoute = "cannot determine route for request, check your HTTP method & headers are valid"
)

type (
	// The Router type handles incoming requests & routes them to the registered
	// handlers.
	Router struct {
		routes     []*Route
		middleware []MiddlewareFunc
		recovery   RecoverFunc
		log        *logrus.Logger
	}

	// The Route type defines a route that can be used by the router.
	Route struct {
		handler HandlerFunc
		method  string
		headers map[string]string
	}

	// The HandlerFunc type defines what a handler function should look like.
	HandlerFunc func(Request) Response

	// The MiddlewareFunc type defines what a middleware function should look like.
	MiddlewareFunc func(*Request) error

	// The RecoverFunc type defines what a panic recovery function should look like.
	RecoverFunc func(Request, error)

	// The Request type represents an incoming HTTP request.
	Request events.APIGatewayProxyRequest

	// The Response type represents an outgoing HTTP response.
	Response events.APIGatewayProxyResponse
)

// NewRouter creates a new lambda router.
func NewRouter() *Router {
	return &Router{
		routes:     []*Route{},
		middleware: []MiddlewareFunc{},
		log:        logrus.New(),
	}
}

// Handler adds a given handler to the router.
func (r *Router) Handler(method string, fn HandlerFunc) *Route {
	route := &Route{
		handler: fn,
		method:  method,
		headers: make(map[string]string),
	}

	r.routes = append(r.routes, route)

	r.log.WithFields(logrus.Fields{
		"method": method,
	}).Info("registered new handler")

	return route
}

// Middleware adds a middleware function to the router. These methods will be called
// prior to the route handler and allow you to modify the inbound request before
// processing it.
func (r *Router) Middleware(fn MiddlewareFunc) *Router {
	r.middleware = append(r.middleware, fn)

	return r
}

// Recovery sets a custom recovery handler that will be used when any
// handlers panic.
func (r *Router) Recovery(fn RecoverFunc) *Router {
	r.recovery = fn

	return r
}

// Logging sets the output for logs generated by the router.
func (r *Router) Logging(out io.Writer, format logrus.Formatter) *Router {
	r.log.Formatter = format
	r.log.Out = out

	return r
}

// HandleRequest determines which route an incoming HTTP request should be sent down. If no route has been
// specified for a given HTTP method, an error is returned.
func (r *Router) HandleRequest(req Request) (Response, error) {
	var resp Response

	defer r.recover(req)
	ts := time.Now()

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
	}).Info("handling incoming request")

	// Look through each route
	for _, route := range r.routes {
		// If the route supports the request, use it.
		if route.canRoute(req) {
			// Run any registered middleware
			for _, mid := range r.middleware {
				// If one returns an error, return a 500 response containing the error
				if err := mid(&req); err != nil {
					resp.Encode(err, http.StatusInternalServerError)

					return resp, nil
				}
			}

			resp := route.handler(req)

			r.log.WithFields(logrus.Fields{
				"status":    resp.StatusCode,
				"duration":  time.Since(ts).String(),
				"requestId": req.RequestContext.RequestID,
			}).Info("finished handling request")

			return resp, nil
		}
	}

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
		"duration":  time.Since(ts).String(),
	}).Error("no handler specified to handle request")

	// Otherwise, create an error response
	resp.Encode(errNoRoute, http.StatusBadRequest)

	return resp, nil
}

func (r *Router) recover(req Request) {
	var err error

	// If a panic was thrown
	if rec := recover(); rec != nil {
		// Attempt to parse it
		switch x := rec.(type) {
		case string:
			err = errors.New(x)
		case error:
			err = x
		default:
			err = fmt.Errorf("%s", x)
		}

		r.log.WithFields(logrus.Fields{
			"requestId": req.RequestContext.RequestID,
			"error":     err.Error(),
		}).Error("recovered from panic")

		// If a custom recover func was defined, use it.
		if r.recovery != nil {
			r.recovery(req, err)
		}
	}
}

// Headers allows you to specify headers a request should have in order to
// use this route.
func (r *Route) Headers(pairs ...string) *Route {
	// Loop through the headers
	for i := 0; i < len(pairs); i += 2 {
		// If we have an odd number of pairs, skip the last one.
		if len(pairs) < i+1 {
			break
		}

		key := pairs[i]
		value := pairs[i+1]

		// Register the required header
		r.headers[key] = value
	}

	return r
}

// CanRoute determines if the incoming request should use this route.
func (r *Route) canRoute(req Request) bool {
	// Loop through the expected headers & values
	for expKey, expValue := range r.headers {
		// If the header key is no present, we don't support this request
		if _, ok := req.Headers[expKey]; !ok {
			return false
		}

		// If the value is not what we expect from this key, we don't support
		// this request.
		if value := req.Headers[expKey]; value != expValue {
			return false
		}
	}

	// If the request method does not match this route's method, we don't
	// support this request.
	if req.HTTPMethod != r.method {
		return false
	}

	return true
}

// Encode writes the given data to the response in JSON format and sets the
// response status code.
func (r *Response) Encode(data interface{}, status int) error {
	r.StatusCode = status

	json, err := json.Marshal(data)

	if err != nil {
		return fmt.Errorf("failed to encode response body, %v", err)
	}

	r.Body = string(json)
	r.Headers["Content-Type"] = "application/json"

	return nil
}
