// Package lux contains types for creating an HTTP router for use in AWS lambda functions. The router supports
// RESTful HTTP methods & contains configuration for logging, request filtering & panic recovery.
package lux

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/aws/aws-lambda-go/events"
)

var (
	errNotAllowed    = errors.New("not allowed")
	errNotAcceptable = errors.New("not acceptable")
)

type (
	// The Router type handles incoming requests & routes them to the registered
	// handlers.
	Router struct {
		routes     []*Route
		middleware []HandlerFunc
		recovery   RecoverFunc
		log        *logrus.Logger
	}

	// The Route type defines a route that can be used by the router.
	Route struct {
		handler HandlerFunc
		method  string
		headers map[string]string
		queries map[string]string
	}

	// The HandlerFunc type defines what a handler function should look like.
	HandlerFunc func(ResponseWriter, *Request)

	// The RecoverFunc type defines what a panic recovery function should look like.
	RecoverFunc func(Request, error)

	// The Request type represents an incoming HTTP request.
	Request events.APIGatewayProxyRequest

	// The Response type represents an outgoing HTTP response.
	Response events.APIGatewayProxyResponse

	// The Headers type represents the HTTP response headers.
	Headers map[string]string

	// The ResponseWriter type allows for interacting with the HTTP response similarly to a triaditional
	// HTTP handler in go.
	ResponseWriter interface {
		Write([]byte) (int, error)
		WriteHeader(int)
		Header() *Headers
	}

	responseWriter struct {
		code    int
		headers Headers
		body    []byte
	}
)

// NewRouter creates a new lambda router.
func NewRouter() *Router {
	return &Router{
		routes:     []*Route{},
		middleware: []HandlerFunc{},
		log:        logrus.New(),
	}
}

// Handler adds a given handler to the router.
func (r *Router) Handler(method string, fn HandlerFunc) *Route {
	route := &Route{
		handler: fn,
		method:  method,
		headers: make(map[string]string),
		queries: make(map[string]string),
	}

	r.routes = append(r.routes, route)

	r.log.WithFields(logrus.Fields{
		"method": method,
	}).Info("registered new handler")

	return route
}

// Middleware adds a middleware function to the router. These methods will be called
// prior to the route handler and allow you to modify the inbound request before
// processing it.
func (r *Router) Middleware(fn HandlerFunc) *Router {
	r.middleware = append(r.middleware, fn)

	return r
}

// Recovery sets a custom recovery handler that will be used when any
// handlers panic.
func (r *Router) Recovery(fn RecoverFunc) *Router {
	r.recovery = fn

	return r
}

// Logging sets the output for logs generated by the router.
func (r *Router) Logging(out io.Writer, format logrus.Formatter) *Router {
	r.log.Formatter = format
	r.log.Out = out

	return r
}

// HandleRequest determines which route an incoming HTTP request should be sent down. If no route has been
// specified for a given HTTP method, an error is returned.
func (r *Router) HandleRequest(req Request) (Response, error) {
	defer r.recover(req)
	ts := time.Now()

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
	}).Info("handling incoming request")

	// Look through each route
	for _, route := range r.routes {
		// If the route's method is correct but the request is not acceptable
		if err := route.canRoute(req); err == errNotAcceptable {
			return NewResponse(err.Error(), http.StatusNotAcceptable)
		} else if err == errNotAllowed {
			// If the method doesn't match, skip to the next route.
			continue
		}

		w := &responseWriter{
			code:    http.StatusOK,
			headers: make(Headers),
			body:    []byte{},
		}

		// Run any registered middleware
		for _, mid := range r.middleware {
			// Return a response if the middleware warrants it
			if mid(w, &req); w.code != http.StatusOK {
				return w.getResponse(), nil
			}
		}

		route.handler(w, &req)

		resp := w.getResponse()

		r.log.WithFields(logrus.Fields{
			"status":    resp.StatusCode,
			"duration":  time.Since(ts).String(),
			"requestId": req.RequestContext.RequestID,
		}).Info("finished handling request")

		return resp, nil
	}

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
		"duration":  time.Since(ts).String(),
	}).Error("no handler specified to handle request")

	// Otherwise, create an error response
	return NewResponse(errNotAllowed.Error(), http.StatusMethodNotAllowed)
}

func (r *Router) recover(req Request) {
	var err error

	// If a panic was thrown
	if rec := recover(); rec != nil {
		// Attempt to parse it
		switch x := rec.(type) {
		case string:
			err = errors.New(x)
		case error:
			err = x
		default:
			err = fmt.Errorf("%s", x)
		}

		r.log.WithFields(logrus.Fields{
			"requestId": req.RequestContext.RequestID,
			"error":     err.Error(),
		}).Error("recovered from panic")

		// If a custom recover func was defined, use it.
		if r.recovery != nil {
			r.recovery(req, err)
		}
	}
}

// Headers allows you to specify headers a request should have in order to
// use this route.
func (r *Route) Headers(pairs ...string) *Route {
	// Loop through the headers
	for i := 0; i < len(pairs); i += 2 {
		// If we have an odd number of pairs, skip the last one.
		if len(pairs) < i+1 {
			break
		}

		key := pairs[i]
		value := pairs[i+1]

		// Register the required header
		r.headers[key] = value
	}

	return r
}

// Queries allows you to specify query parameters and values a request should have
// in order to use this route.
func (r *Route) Queries(pairs ...string) *Route {
	// Loop through the headers
	for i := 0; i < len(pairs); i += 2 {
		// If we have an odd number of pairs, skip the last one.
		if len(pairs) < i+1 {
			break
		}

		key := pairs[i]
		value := pairs[i+1]

		// Register the required query
		r.queries[key] = value
	}

	return r
}

// CanRoute determines if the incoming request should use this route.
func (r *Route) canRoute(req Request) error {
	// If the request method does not match this route's method, we don't
	// support this request.
	if req.HTTPMethod != r.method {
		return errNotAllowed
	}

	// Loop through the expected headers & values
	for expKey, expValue := range r.headers {
		// If the header key is not present, we don't support this request
		if value, ok := req.Headers[expKey]; !ok || (value != expValue && expValue != "*") {
			return errNotAcceptable
		}
	}

	// Loop through the expected queries & values
	for expKey, expValue := range r.queries {
		// If the query key is not present, we don't support this request
		if value, ok := req.QueryStringParameters[expKey]; !ok || value != expValue {
			return errNotAcceptable
		}
	}

	return nil
}

// NewResponse creates a new response object with a JSON encoded body and given
// status code.
func NewResponse(data interface{}, status int) (Response, error) {
	json, err := json.Marshal(data)

	if err != nil {
		return Response{}, fmt.Errorf("failed to encode response body, %v", err)
	}

	resp := Response{
		StatusCode: status,
		Body:       string(json),
		Headers:    make(map[string]string),
	}

	resp.Headers["Content-Type"] = "application/json"

	return resp, nil
}

func (w *responseWriter) Write(data []byte) (int, error) {
	w.body = data

	return len(data), nil
}

// WriteHeader writes the given HTTP status code to the HTTP response.
func (w *responseWriter) WriteHeader(code int) {
	w.code = code
}

// Headers obtains the HTTP response headers for a request.
func (w *responseWriter) Header() *Headers {
	return &w.headers
}

// Set creates a new header with the given key and value.
func (h Headers) Set(key, val string) {
	h[key] = val
}

func (w *responseWriter) getResponse() Response {
	return Response{
		StatusCode: w.code,
		Body:       string(w.body),
		Headers:    w.headers,
	}
}
