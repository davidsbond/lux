package lux

import (
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/aws/aws-lambda-go/events"
)

const (
	errNoRoute = "cannot determine route for request, check your HTTP method & headers are valid"
)

type (
	// The Router type handles incoming requests & routes them to the registered
	// handlers.
	Router struct {
		routes   []*Route
		recovery RecoverFunc
		log      *logrus.Logger
	}

	// The Route type defines a route that can be used by the router.
	Route struct {
		handler HandlerFunc
		method  string
		headers map[string]string
	}

	// The HandlerFunc type defines what a handler function should look like.
	HandlerFunc func(events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error)

	// The RecoverFunc type defines what a panic recovery function should look like.
	RecoverFunc func(events.APIGatewayProxyRequest, error)
)

// NewRouter creates a new lambda router.
func NewRouter() *Router {
	return &Router{
		routes: []*Route{},
		log:    logrus.New(),
	}
}

// Handler adds a given handler to the router.
func (r *Router) Handler(method string, fn HandlerFunc) *Route {
	route := &Route{
		handler: fn,
		method:  method,
		headers: make(map[string]string),
	}

	r.routes = append(r.routes, route)

	r.log.WithFields(logrus.Fields{
		"method": method,
	}).Info("registered new handler")

	return route
}

// Recovery sets a custom recovery handler that will be used when any
// handlers panic.
func (r *Router) Recovery(fn RecoverFunc) *Router {
	r.recovery = fn

	return r
}

// Logging sets the output for logs generated by the router.
func (r *Router) Logging(out io.Writer, format logrus.Formatter) *Router {
	r.log.Formatter = format
	r.log.Out = out

	return r
}

// HandleRequest determines which route an incoming HTTP request should be sent down. If no route has been
// specified for a given HTTP method, an error is returned.
func (r *Router) HandleRequest(req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	defer r.recover(req)
	ts := time.Now()

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
	}).Info("handling incoming request")

	// Look through each route
	for _, route := range r.routes {
		// If the route supports the request, use it.
		if route.canRoute(req) {

			resp, err := route.handler(req)

			r.log.WithFields(logrus.Fields{
				"status":    resp.StatusCode,
				"duration":  time.Since(ts).String(),
				"requestId": req.RequestContext.RequestID,
			}).Info("finished handling request")

			return resp, err
		}
	}

	r.log.WithFields(logrus.Fields{
		"method":    req.HTTPMethod,
		"params":    req.QueryStringParameters,
		"requestId": req.RequestContext.RequestID,
		"duration":  time.Since(ts).String(),
	}).Error("no handler specified to handle request")

	// Otherwise, create an error response
	return events.APIGatewayProxyResponse{
		StatusCode: http.StatusBadRequest,
		Body:       errNoRoute,
	}, nil
}

func (r *Router) recover(req events.APIGatewayProxyRequest) {
	var err error

	// If a panic was thrown
	if rec := recover(); rec != nil {
		// Attempt to parse it
		switch x := rec.(type) {
		case string:
			err = errors.New(x)
		case error:
			err = x
		default:
			err = fmt.Errorf("%s", x)
		}

		r.log.WithFields(logrus.Fields{
			"requestId": req.RequestContext.RequestID,
			"error":     err.Error(),
		}).Error("recovered from panic")

		// If a custom recover func was defined, use it.
		if r.recovery != nil {
			r.recovery(req, err)
		}
	}
}

// Headers allows you to specify headers a request should have in order to
// use this route.
func (r *Route) Headers(pairs ...string) *Route {
	// Loop through the headers
	for i := 0; i < len(pairs); i += 2 {
		// If we have an odd number of pairs, skip the last one.
		if len(pairs) < i+1 {
			break
		}

		key := pairs[i]
		value := pairs[i+1]

		// Register the required header
		r.headers[key] = value
	}

	return r
}

// CanRoute determines if the incoming request should use this route.
func (r *Route) canRoute(req events.APIGatewayProxyRequest) bool {
	// Loop through the expected headers & values
	for expKey, expValue := range r.headers {
		// If the header key is no present, we don't support this request
		if _, ok := req.Headers[expKey]; !ok {
			return false
		}

		// If the value is not what we expect from this key, we don't support
		// this request.
		if value := req.Headers[expKey]; value != expValue {
			return false
		}
	}

	// If the request method does not match this route's method, we don't
	// support this request.
	if req.HTTPMethod != r.method {
		return false
	}

	return true
}
